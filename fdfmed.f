      SUBROUTINE fdfmed
c                                                                       
c                          PROCESS FDFMOD
c                          ------- ------
c
c  Document date:  25 July 1990
c
c                     Finite-Difference Foward Modelling using the
c                              45-degree algorithm
c
c
c      The finite-difference migration technique is an effective way to handle
c   many types of migration problems.  Often it is necessary to do the reverse
c   problem -- given a subsurface structure and velocity field,  calculate its 
c   response on a zero-offset section, or unmigrated section  ( a zero-offset 
c   section is a good approximation to a stacked section in regions of small dip).
c   This technique is very similar to migration except that the receivers are
c   upward continued to the surface P(x,z=0,t), whereas the migration process
c   downward continues the receivers - via a finite-difference approximation to
c   the scalar wave equation - into the subsurface and collecting terms at P(x,z,t=0).
c   Input to FDFMOD can be generated by process SYN and FILTER, and should represent 
c   the structure you care to model( or unmigrate).  Therefore, point sources should
c   become diffractions, interfaces should increase both dip and length ect...
c
c   This process will most likely be used in conjuction with processes SYN 
c   and FILTER which generate seismic traces for modelling
c
c     Limitations
c     ___________
c
c   see process FDMIGR
c
c
c     Some Important Parameters
c     _________________________
c
c       The parameter Rho is inserted into the expression for the 
c  discretization of the time derivative. This serves to counteract any
c  potential growing waves from the expression for migration, as an
c  explicit damping with time. It can be thought of as a "numerical
c  viscosity".  A value of Rho less than 1 reinforces stability.
c  However, any deviation of Rho away from 1, by at most 1 percent,
c  results in some loss of signal as well as noise.
c        In the discretization of depth, the parameter Theta is
c  introduced, with the most natural value being .500.  If Theta = 0 is
c  used, there is a tendency to overshoot on variations, whereas 
c  Theta = 1 will produce an overdamping of change.
c        To discretize the horizontal distance component, an
c  approximation to the second derivative is found by an iterative
c  method.  When the iteration is truncated, the parameter Gamma is
c  introduced, which is allowed to vary between .08 and .17, based
c  primarily on the look of migrated sections.  If Gamma is allowed to
c  increase too much more, spurious noise results.
c         In the ideal case, Tau would equal the sample rate of the
c  data, meaning that the entire section would be migrated exactly one
c  sample rate step at each pass through the section. While this scheme
c  reduces the errors, it is impractical due to the huge run-time
c  needed. In practise, Tau should be chosen in the range of 20 to 200 
c  ms. (.02 to .2 secs), with the smaller Tau values producing greater
c  accuracy.  It is possible to vary Tau vertically (not recommended), 
c  and should be done in order to save run-time. Generally, the value of 
c  Tau should decrease from shallow to deep data times. This is because 
c  greater accuracy is needed in the migration of the deeper events where
c  the greatest movement is taking place.
c         More detailed explanation of the origin of these parameters,
c  and some results of allowing them to vary, may be found in the paper
c  published by H. Brysk (Geophysics: May 1983).
c
c
c  PARAMETER DICTIONARY
c  --------- ----------
c  DX     - Trace separation distance.  This is the distance between reflection
c           points.  DX is a constant for the entire seismic line.
c           REQUIRED.  range 1.0 to 500.0      e.g.  dx 25
c  FNO    - The first shot/rp number the parameter list applies to.
c           Preset = the first shot/rp received.    e.g.   fno 101
c  LNO    - The last shot/rp number the parameter list applies to.
c           Preset = the last shot/rp received.    e.g.   lno 101
c  VTP    - The rms velocity to use in migration.  The rms velocity function is
c           the same as the velocity function used to moveout the data.  Given
c           as velocity-time pairs.  Velocities not specified are calculated
c           through interpolation and "straight-lining" from the ends.
c           Times must be given in seconds.
c           Preset = none    velocity range 350 to 32000
c  VDIX   - The interval velocities to use in migrating, given as interval
c           velocity-time pairs.  Time must be in seconds.
c           Preset = none     range 350 to 32000
c  BPAD   - The number of zero amplitude traces to insert prior to the first
c           trace.
c           Preset = 1   range 1 to 500      e.g. bpad 10
c  EPAD   - The number of zero amplitude traces to append after the last trace.
c           Preset = 1   range 1 to 500      e.g. epad 10
c  OPAD   - A switch indicating that the pad traces (both bpad and epad) should
c           be output in addition to the migrated input.
c           Preset = no   range yes/no       e.g.   opad yes
c  NRHO   - A parameter used to control the Tau step interpolation.
c           Preset = 2.0   range 0. to 10000  
c  FCRHO  - A parameter used to control the Tau step interpolation.
c           Preset = .99   range .0001 to 1.
c  RHO    - A "hidden" migration parameter discussed above.
c           Preset = .9990   range  0 to .9999  
c  THETA  - A "hidden" migration parameter discussed above.
c           Preset = .501  range  0 to 1.0
c  GAMMA  - A "hidden" migration parameter discussed above.
c           Preset = .125   range  .08 to .17
c  TSTEPS - A set of time-delta-tau pairs governing the tau step size (delta-
c           tau) in the time interval terminating with the time given.
c           Up to 7 pairs of time and delta-tau may be given.  The user must give
c           the max time modelled in last pair. e.g. 8.0 0.10 with 8.0 secs being 
c           last sample modelled. It is HIGHLY suggested that the user use only one 
c           time-delta-tau pair and vary the size of the step to conserve cpu time.
c           units are in seconds
c           Preset = REQUIRED            
c  NX     - The total number of traces, including pads, to migrate.  The entire
c           seismic line must be transformed from TX (time-space) to XT
c           (space-time).  FDDIFF requires much extra disk I/O if the entire
c           seismic line (nx*maxsam) is larger than the computer memory
c           allocated for the transformation (the Cray does not have a virtual
c           memory).  NX does not have to be a power of 2.
c           Preset = 4096       e.g.   nx 500
c  MAXSAM - The maximum number of samples per trace, including the deep
c           water delay, to migrate.  A trace exceeding MAXSAM will be
c           truncated.
c           Preset = the number of samples plus delay of the first trace.
c  PATH   - The pathname (filename) of a scratch file FDDIFF should use
c           for the intermediate transposed data.  The purpose of this
c           parameter is to allow the user to specify the exact diskpartition
c           to use in case the "current" partition does not have enough
c           space.
c           preset = a scratch file in the current directory
c           e.g.    path /user/scratch/moreroom
c
c   
c  EXAMPLES:
c  ---------
c  1)  Generate a constant velocity hyperbola.
c        ( in script file examples/c_hypcvel)
c      procs syn filter diskoa fdfmod diskob end
c      syn
c         fno  1 lno 49  ntrcs 1 secs 3.0 tva 3.1 2500 1 end
c         fno 50 lno 50  ntrcs 1 secs 3.0 
c          tva .3 2500 1 .7 2500 1  1.0 2500 1 1.3 2500 1 1.8 2500 1 end
c         fno 51 lno 100 ntrcs 1 secs 3.0 tva 3.1 2500 1 end
c      end                    
c      filter
c            pass 10 20 end
c      end
c      diskoa
c         opath impulsecvel.segy fon 1 end
c      end
c      fdfmod
c          nx 102 bpad 1 epad 1 opad no maxsam 751 dx 25 maxdip .001 
c          path scratch vtp 2500 0.0 2500 3.0 tsteps 3.00 .1 end
c      end
c      diskob
c            opath impulsecvel.fddiff fon 1 end
c      end
c      end
c
c  2)  Generate a hyperbola with laterally varying velocity.
c      See script file examples/c_hypvlat.
c  3)  Generate a hyperbola with rms velocity.
c      See script file examples/c_rms.fddiff.
c  4)  Generate a hyperbola with dip.  
c      See script file examples/c_mod.dip.refl
c
c
c  Copyright (C) by The Regents of The University of California, 1988
c  Written by Paul Henkart, Scripps Institution of Oceanography, La Jolla, Ca.
c  and by Veritas Seismic Processors, Ltd., Calgary, Alberta.
c  ALL RIGHTS RESERVED.
c  Modified by Graham M. Kent 7/90
c
      PARAMETER ( npars = 25 )                                          ! the number of user parameters
      PARAMETER ( maxvel = 55 )                                         ! the maximum number of velocity-time pairs
      PARAMETER ( maxdts = 10 )                                         ! the maximum number of time- delta tau pairs
      CHARACTER*80 token
      CHARACTER*6 names(npars)
      CHARACTER*1 types(npars)                                          ! the type of parameter
      REAL vals(npars)                                                  ! holds the REAL parameter values
      DIMENSION lvals(npars)                                            ! holds the INTEGER parameter values
      EQUIVALENCE (vals(1),lvals(1))                                    ! must be the same so that wrdisc scr works!
c
      DIMENSION vels(maxvel*2), dtaus(maxdts*2)
      COMMON /edits/ ierror, iwarn, irun, now, icompt
      COMMON /fdmigr/ junit, nlists, nwrds
c
      INTEGER fno, bpad, epad, opad, bclpad, eclpad
      REAL maxdip, nrho, ldx
c
      EQUIVALENCE ( lprint, lvals(1) ),
     2            ( fno, lvals(2) ),
     3            ( lno, lvals(3) ),
     4            ( dx, vals(4) ),
     5            ( maxdip, vals(5) ),
     6            ( vtp, vals(6) ),
     7            ( vdix, vals(7) ),
     8            ( bpad, lvals(8) ),
     9            ( epad, lvals(9) ),
     *            ( opad, lvals(10) ),
     1            ( velmul, vals(11) ),
     2            ( nrho, vals(12) ),
     3            ( fcrho, vals(13) ),
     4            ( rho, vals(14) ),
     5            ( theta, vals(15) ),
     6            ( gamma, vals(16) ),
     7            ( tsteps, vals(17) ),
     8            ( ntrpl, lvals(18) )
      EQUIVALENCE ( nlines, lvals(19) ),
     *            ( ldx, vals(20) ),
     1            ( bclpad, lvals(21) ),
     2            ( eclpad, lvals(22) ),
     3            ( nx, lvals(23) ),
     4            ( maxsam, lvals(24) ),
     5            ( lunt, lvals(25) )
      DATA names /'LPRINT', 'FNO   ', 'LNO   ', 'DX    ', 'MAXDIP',
     *            'VTP   ', 'VDIX  ', 'BPAD  ', 'EPAD  ', 'OPAD  ',
     *            'VELMUL', 'NRHO  ', 'FCRHO ', 'RHO   ', 'THETA ',
     *            'GAMMA ', 'TSTEPS', 'NTRPL ', 'NLINES', 'LDX   ',
     *            'BCLPAD', 'ECLPAD', 'NX    ', 'MAXSAM', 'PATH  ' /
      DATA types / 3*'L', 4*'F', 2*'L', 'A', 7*'F', 2*'L', 'F', 4*'L',
     *             'A' /
c**** 
c****    Set the parameter presets and various variable presets
c****
      lprint = 0
      fno  = 0
      lno = 0
      dx = 0.
      maxdip = 0.
      nvels = 0
      vtp = 0.
      vdix = 0.
      ivtype = 0
      bpad = 1
      epad = 1
      opad = 0.
      velmul = 1.0
      nrho = 2.
      fcrho = .99
      rho = .999
      theta = .501
      gamma = .125
      ndtaus = 0
      tsteps = 0.
      ntrpl = 0
      nlines = 1.
      ldx = 0.
      bclpad = 0
      eclpad = 0
      nx = 4096
      maxsam = 0
      lunt = 0
      CALL getfil( 1, junit, token, istat )                             ! get a file for the DISK parameters
c****
c****     get the user's parameters -  there must be something, at least an "end"
c****
      ntokes = 0                                                        ! count the tokens
  100 CONTINUE
      CALL getoke( token, nchars )                                      ! get a token and it's length
      CALL upcase( token, nchars )                                      ! convert parameter names to upper case
      IF( nchars .EQ. 0 ) THEN                                          ! anything there?
          CALL rdline                                                   ! nope, get another line
          ntokes = 0
          GOTO 100
      ENDIF
      ntokes = ntokes + 1
  110 DO 120 i = 1, npars
         nparam = i
         IF( token(1:nchars) .EQ. names(nparam) ) GOTO 150
  120 CONTINUE
      IF( token(1:nchars) .EQ. 'END' ) GOTO 200
      IF( names(lparam) .EQ. 'VTP' .OR. names(lparam) .EQ. 'VDIX'
     *  .OR. names(lparam) .EQ. 'TSTEPS' ) GOTO 160
      IF( token(1:nchars) .EQ. 'END') GOTO 200
      PRINT *,' ***  ERROR  ***  No such parameter as ',token(1:nchars)
      ierror = ierror + 1
      GOTO 100
  150 CONTINUE
      lparam = nparam
c****  
c****   Got the parameter name, now get the value
c****
      CALL getoke( token, nchars )                                      ! get the value
      CALL upcase( token, nchars )                                      ! convert to upper case
      ntokes = ntokes + 1
      IF( nchars .EQ. 0 ) THEN
          CALL rdline
          ntokes = 0
          GOTO 150
      ENDIF
      IF( types(nparam) .EQ. 'A' ) THEN
          IF( names(nparam) .EQ. 'OPAD' ) THEN
              IF( token(1:1) .EQ. 'Y' ) opad = 1
          ENDIF
          IF( names(nparam) .EQ. 'PATH' ) THEN
              CALL getfil( 3, lunt, token(1:nchars), istat )
              IF( istat .NE. 0 ) THEN
                  PRINT *,' ***  ERROR  ***   Can not open file ',path
                  ierror = ierror + 1
              ENDIF
          ENDIF
          GOTO 100
      ENDIF
  160 CALL dcode( token, nchars, areal, istat )                         ! convert the alpha number to an internal machine number
      IF( istat .NE. 2 ) ierror = ierror + 1                            ! was the an error decoding it?
      IF( types(lparam) .EQ. 'L' ) THEN
          lvals(lparam) = areal                                         ! convert the real to INTEGER*4
      ELSE
          vals(lparam) = areal                                          ! move the real to the parameter
          IF( names(lparam) .EQ. 'VTP' ) THEN
              ivtype = 1
              nvels = nvels + 1
              vels(nvels) = areal
          ENDIF
          IF( names(nparam) .EQ. 'VDIX' ) THEN
              ivtype = 2
              nvels = nvels + 1
              vels(nvels) = areal
          ENDIF
          IF( names(lparam) .EQ. 'TSTEPS' ) THEN
              ndtaus = ndtaus + 1
              dtaus(ndtaus) = areal
          ENDIF
      ENDIF
      GOTO 100
c****
c****    Do the parameter validity checks
c****
  200 CONTINUE
      IF( fno .LT. 0 ) THEN
          PRINT *,' ***  ERROR  ***  FNO must be positive.'
          ierror = ierror + 1
      ENDIF
      IF( lno .LT. 0 ) THEN
          PRINT *,' ***  ERROR  ***  LNO must be positive.'
          ierror = ierror + 1
      ENDIF
      IF( dx .LT. 1. .OR. dx .GT. 500. ) THEN
          PRINT *,' ***  ERROR  ***  DX must be between 1 and 500.'
          ierror = ierror + 1
      ENDIF
      IF( nvels .EQ. 0 ) THEN
          PRINT *,' ***  ERROR  ***  A velocity must be given.'
          ierror = ierror + 1
      ENDIF
      IF( ivtype .NE. lvtype .AND. nlists .GT. 1 ) THEN
          PRINT *,' ***  ERROR  ***  Only one velocity type may be ',
     *      'given.'
          ierror = ierror + 1
      ENDIF
      IF( nvels/2*2 .NE. nvels ) THEN
          PRINT *,' ***  ERROR  ***  Velocities must be in pairs.'
          ierror = ierror + 1
      ENDIF
      DO 1234 i = 1, nvels, 2
         IF( vels(i) .LT. 350. .OR. vels(i) .GT. 32000. ) THEN
             PRINT *,' ***  ERROR  ***  Velocities must be between',
     *          ' 350 and 32000.'
             ierror = ierror + 1
         ENDIF
         IF( i .NE. 1 .AND. vels(i+1) .LE. vels(i-1) ) THEN
             PRINT *,' ***  ERROR  ***  The times within the velocity ',
     *          ' time pair must increase.'
             ierror = ierror + 1
         ENDIF
 1234 CONTINUE
      IF( bpad .LT. 1 .OR. bpad .GT. 500 ) THEN
          PRINT *,' ***  ERROR  ***  BPAD must be between 1 and 500.'
          ierror = ierror + 1
      ENDIF
      IF( epad .LT. 1 .OR. epad .GT. 500 ) THEN
          PRINT *,' ***  ERROR  ***  EPAD must be between 1 and 500.'
          ierror = ierror + 1
      ENDIF
      IF( nrho .LT. 0. .OR. nrho .GT. 10000. ) THEN
          PRINT *,' ***  ERROR  ***  NRHO must be between 0 and 10000.'
          ierror = ierror + 1
      ENDIF
      IF( fcrho .LT. .0001 .OR. fcrho .GT. 1. ) THEN
          PRINT *,' ***  ERROR  ***  FCRHO must be between .0001 and ',
     *            '1.0'
          ierror = ierror + 1
      ENDIF
      IF( rho .LT. 0. .OR. rho .GT. .9999 ) THEN
          PRINT *,' ***  ERROR  ***  RHO must be between 0 and .9999'
          ierror = ierror + 1
      ENDIF
      IF( theta .LT. 0. .OR. theta .GT. 1.0 ) THEN
          PRINT *,' ***  ERROR  ***  THETA must be between 0. and 1.0'
          ierror = ierror + 1
      ENDIF
      IF( gamma .LT. .08 .OR. gamma .GT. .17 ) THEN
          PRINT *,' ***  ERROR  ***  GAMMA must be between .08 and .17'
          ierror = ierror + 1
      ENDIF
      IF( tsteps .EQ. 0 ) THEN
          PRINT *,' ***  ERROR  ***  TSTEPS must be given.'
          ierror = ierror + 1
      ENDIF
      DO 2345 i = 1, ndtaus, 2
         IF( dtaus(i) .LT. 0. .OR. dtaus(i) .GT. 20. ) THEN
             PRINT *,' ***  ERROR  ***  TSTEPS time ',dtaus(i),
     *          'is not between 0 and 20.'
             ierror = ierror + 1
         ENDIF
         IF( dtaus(i+1) .LT. .00001 .OR. dtaus(i+1) .GT. .5 ) THEN
             PRINT *,' ***  ERROR  ***  TSTEPS delta-tau ',dtaus(i+1),
     *          'is not between 0 .AND. .5'
             ierror = ierror + 1
         ENDIF
         IF( i .NE. 1 .AND. dtaus(i) .LE. dtaus(i-2) ) THEN
             PRINT *,' ***  ERROR  ***  TSTEPS times must increase.'
             ierror = ierror + 1
         ENDIF
 2345 CONTINUE
      IF( ntrpl .NE. 0 .AND. ntrpl .LT. 3 .OR. ntrpl .GT. 1000 ) THEN
          PRINT *,' ***  ERROR  ***  NTRPL must be between 3 and 1000.'
          ierror = ierror + 1
      ENDIF
      IF( nlines .NE. 1 .AND. nlines .LT. 3 .OR. nlines .GT. 1000 ) THEN
          PRINT *,' ***  ERROR  ***  NLINES must be between 3 and 1000.'
          ierror = ierror + 1
      ENDIF
      IF( bclpad .LT. 0 .OR. bclpad .GT. 500 ) THEN
          PRINT *,' ***  ERROR  ***  BCLPAD must be between 0 and 500.'
          ierror = ierror + 1
      ENDIF
      IF( eclpad .LT. 0 .OR. eclpad .GT. 500 ) THEN
          PRINT *,' ***  ERROR  ***  ECLPAD must be between 0 and 500.'
          ierror = ierror + 1
      ENDIF
c****
c****    Do some more presetting
c****
      lvals(6) = nvels                                                  ! clobber vtp
      lvals(7) = ivtype                                                 ! clobber vdix
      tsteps = ndtaus
c****
c****    Write the FDDIFF parameters to a disc file  and get another list!
c****
      nwrds = npars 
      CALL wrdisc( junit, lvals, nwrds )
      IF( nvels .GT. 0 ) CALL wrdisc( junit, vels, nvels )
      IF( ndtaus .GT. 0 ) CALL wrdisc( junit, dtaus, ndtaus )
      nlists = nlists + 1
      IF( nlists .GT. 198 ) THEN
         PRINT *,' ***  ERROR  ***  FDDIFF can only handle 198 control',
     *       ' points.'
          ierror = ierror + 1
      ENDIF
c
      IF( IAND(lprint,1) .NE. 0 ) THEN
          PRINT *,(lvals(i),i=1,3), (vals(i),i=4,5),lvals(6),lvals(7)
          PRINT *,(lvals(i),i=8,10), (vals(i),i=11,17)
          PRINT *,(lvals(i),i=18,19), vals(20), (lvals(i),i=21,nwrds)
          IF( nvels .NE. 0 ) PRINT *,' vels:',(vels(i),i=1,nvels)
          IF( ndtaus .NE. 0 ) PRINT *,' dtaus:',(dtaus(i),i=1,ndtaus)
      ENDIF
c****
c****    finish up the parameter reading
c****
 2000 CONTINUE
      CALL getoke( token, nchars )                                       ! get the next token
      CALL upcase( token, nchars )
      ntokes = ntokes + 1
      IF( nchars .LE. 0 ) THEN
          IF( now .EQ. 1 ) PRINT *,' <  ENTER PARAMETERS  >'
          CALL rdline                                                   ! get a new line of parameters
          ntokes = 0
          GOTO 2000
      ENDIF
      lno = 0
      nvels = 0
      ndtaus = 0
      lvtype = ivtype                                                   ! save the velocity type for the next list
      IF( token(1:nchars) .NE. 'END' .OR. nchars .NE. 3 ) GOTO 110

      RETURN
      END
